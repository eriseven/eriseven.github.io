---
layout: post
title: 蒙特卡罗方法简介
---

# 蒙特卡罗方法简介

[原文](https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/monte-carlo-methods-mathematical-foundations)

```
起初我们不希望将课程设计这么长，包含如此多关于概率论和统计学的内容，但事实是，如果你想了解蒙特卡罗方法，你将要大量涉及到概率论与数理统计理论。

在这一章，我们将试图了解些蒙特卡罗方法是什么，它们是如何工作的，应用于哪些领域，以及为什么应用于这些领域。这种快速的介绍,读者没有时间或得到任何进一步的欲望。但是你可能需要阅读所有剩下的章节，如果你是认真的学习这些方法是什么。

这一课更多地介绍那些构建蒙特卡罗方法的数学工具。蒙特卡洛方法本身将在下一课（蒙特卡罗方法实践）中进一步解释。
```

## 关于蒙特卡洛

就像许多在CG文献中经常出现的其他术语一样，蒙特卡洛在于初学者看来是一个神奇的词汇。一些在计算机图形学中使用的数学工具某种程度上比较复杂，例如球谐函数，相反蒙特卡洛的原理就其本身而言相对简单(并不意味着容易)。这很棒，因为这种方法能极其方便的解决各种复杂的问题。蒙特卡洛积分或蒙特卡罗近似大概是一个很古老的方法，可直到1940年代中期才有了这个朗朗上口的名字。蒙特卡洛是摩纳哥公国的一个地区，以其赌场闻名于世。如同我们将在本课程中讲解的，蒙特卡洛方法与统计学领域有很紧密的联系，它本身对提升你在一场机会游戏中输赢的机会很有帮助，比如轮盘，或任何其他涉及到掷骰子，抽牌等机会游戏，都被看作是一个随机过程。蒙特卡洛方法是由一批著名数学家帮助开发并形式化(费米，乌兰，冯·诺依曼，梅特罗波利斯等)，它对于原子弹开发的研究开展是至关重要的，并在计算机紧密相关的现代科学中非常流行(冯诺伊曼本人发明了第一代计算机)。蒙特卡洛积分需要大量计算，如果没有计算机的参与，它将非常乏味冗长，而大规模计算恰好是计算机所擅长的。现在我们回顾了关于蒙特卡洛的历史和最初的命名的起源，让我们尝试解释下什么是蒙特卡洛。可惜，我们前面的介绍很简短，蒙特卡洛方法的数学意义涉及到许多统计学和概率论的重要概念。在着眼介绍蒙特卡洛方法前，我们首先要和大家回顾这些概念。

![picture](https://www.scratchapixel.com/images/upload/monte-carlo-methods/roulette.png?)

## 蒙特卡洛方法简介

![pictrue](https://www.scratchapixel.com/images/upload/monte-carlo-methods/jellybeans01.png?) 

蒙特卡罗是什么？蒙特卡洛方法背后的概念既简单又健壮。然而，很快我们会发现，它需要大量的计算量，这就是为什么它的普及时间与计算机技术的出现相一致的原因。生活中的许多事情都很难准确评估，尤其是涉及到非常大的数字时。例如，虽然并非不可能，但要计算1罐1公斤装的果冻豆的的数量可能要花很长时间。你可以用手动一个一个地数，但这可能要花很长时间(这可不是最讨人喜欢的工作)。计算一个国家所有成年人口的平均身高，需要测量每个人的身高，并将其相加，再除以总人数。这是一项可能需要很长时间的任务。我们可以做的是取这个总体的样本然后计算它的平均高度。它不可能准确地给出整个总体的平均高度，但是这个方法给出了一个很近似于真实结果的数字。我们为了速度而放弃了准确性。抽样调查也被称为数据统计就是基于这一我们所熟知的原则的。有趣的是，近似值和整个总体的准确平均值可能有些时候是完全相同的。这只是出于偶然。在大多数情况下，数字将会有所差异。我们可能想问的一个问题是，差异有多大？事实上，随着样本数量的增大，这个近似值收敛于精确的数值。换句话说，近似值和实际结果之间的误差随着样本容量的减小而减小。我们为了速度而放弃了准确性。民调也被称为统计数据是基于这一原则的，我们都很熟悉这一原则。有趣的是，整个种群的近似和准确的平均值可能有些时候是完全相同的。这只是由于偶然。在大多数情况下，数字将会有所不同。我们可能想问的一个问题是，有什么不同吗?事实上，随着样本容量的增大，这个近似值收敛于精确值。换句话说，近似值和实际结果之间的误差随着样本数量的增加而减小。直觉上，这个想法很容易理解，但是在下一章中，我们会将它(从数学的角度)公式化，用另一种不同的方式阐述这个概念。请注意，为了公平起见，样本元素需要等概率地随机选取。

注意，一个人的身高是一个随机数。实际上可以是任何有随机性质的东西。因此，当你对一个统计总体进行抽样时，通过随机地从这个总体中选取元素，并测量它们的高度来估算平均高度，每一个测量结果都是一个随机值(因为样本中的每个人可能有不同的高度)。有趣的是，随机值的总和，是另一个随机值。如果你不能预测每一个用来求和的值是多少，你怎么能预测它们求和的结果呢？因此，求和的结果是一个随机值。

对于一个数学家来说，人口的高度会被称为随机变量，因为组成这个总体的人的身高是随机的。我们通常用大写字母表示随机变量。比如大写字母$X$。

在统计学中，构成总体的要素，如之前所建议的是随机的，用一个小写字母表示，通常是$x$。例如，如果我们写$x_2$，这表示的是第二个人的身高(这是随机的)。所有这些$x$也可以被看作是随机变量$X$的可能结果，如果我们称$X$为随机变量(人口高度)，我们可以用下面的伪数学公式来表示近似成人平均身高的概念:

$$
Approximation(Average(X)) = { 1 \over N} \sum_{n=1}^N x_n.
$$

可以理解为,随机变量$X$平均值的近似值,(一个特定国家的成年人口的高度),等于从这个总体随机选择$N$个成人的高度(样品)的总和($\Sigma$符号),除以$N$(样本数量)。这就是我们所说的蒙特卡罗近似法。它是指,对于一组庞大数量个体的一些属性,通过从该总体随机选择$N$个个体的性质的求平均值作为该总体属性的近似值。你也可以说，蒙特卡罗近似法，实际上是一种用样本求近似值的方法。下一章我们将学到，这个需要被近似的值被称为数学期望。如前所述一个给定的国家的成年人口的高度可以被看作是一个随机变量$X$。但是需要注意，其平均值(例如，通过对所有人的身高求平均值得到，并且每个人的高度值也是一个随机值)是唯一的(为了避免与样本数量(通常用字母$N$表示)混淆,我们将使用$M$表示整个总体的大小):

$$
Average(X) = { 1 \over M\ } (x_1 + x_2 + ... x_M),
$$

这里$x_1, x_2, ... x_M$对应组成前面的总体中每个人的身高(如果我们要举个例子)。在统计学中，随机变量X的平均值被称为**期望**，并被写成$E(X)$。

>总而言之，蒙特卡罗近似法(这是MC方法之一)是一种利用样本来近似随机变量期望的技术。可以用下面的公式来定义它：
>
>$$E(X) \approx { 1 \over N } \sum_{n = 1}^N x_n.$$
>这个数学符号$\approx$表示，这个符号的右边的公式只给出了随机变量$X$期望$E(X)$实际上是随机变量&X&的期望值$E(X)$的"近似"。注意，在某种程度上，它只是随机值($x_n$)的平均值。

这就是所有我们想要揭开的关于蒙特卡洛这个神秘术语背后的秘密。但是，在这个简单介绍的最后，让我们来解释一下这个方法之所以是有用的原因。前面提到过，$E(X)$有时是难以求解的。这意味着你不能以一种有效的方式计算$E(X)$。尤其对庞大规模的“总体”求$E(X)$的时候，例如计算一个国家成年人口的平均身高，的确如此。在这种情况下，MC近似提供了一个至少非常简单和快速的方法来近似这个期望值。它不会给出确切的值，但它可以得到足够近似的结果，同时计算花费如果可能的话仅是计算精确值的几分之一。

## 蒙特卡罗，偏置和无偏射线追踪

为了结束这个简短的介绍，我们认识到你们中很多人都听说过**蒙特卡罗射线追踪**这个术语，还有**偏置**和**无偏**的射线追踪这个词，很可能是看了这个页面，希望能找到解释这些术语的意思。让我们快速地做一下，尽管我们确实建议你们阅读这一课的其余部分以及下面的内容，以便深入地回答这些问题。

![picture](https://www.scratchapixel.com/images/upload/monte-carlo-methods/areacam1.png?)

想象一下你想用数码相机拍张照片。如果你把图像的表面分割成一个普通的网格(或者我们称之为像素)，注意每一个像素实际上都可以被看作是很小但是仍然是连续的表面，在这个场景中，由物体所反射的光会落到上面。这光最终会转化为单一颜色(我们稍后将讨论这个过程)但是如果你从这些像素看过去,您可能注意到,实际上看到不止一个对象,或者不止一个物体的表面的颜色,分别映射于像素的不同区域。我们已经通过图1展示了这个想法。理想情况下，我们要做的是计算从这个表面上反射的光的量。这通常是一个棘手问题，从某种意义上说，没有办法可以在一个像素的表面上对通过这像素的光的数量求积分。虽然我们可以用数学方法来写这个想法，但是这个方程实际上并没有解。

$$
L_{pixel} = \int_{pixel area} L(x_p) dA,
$$

$L$在这里，代表辐射率(正如在放射测量学中解释的那样)。你可以将这个方程理解为"实际数量到达一个像素($L$方程左边也该像素的颜色,最终得救)可以作为输入的积分计算辐射(光的像素)像素区"。就像我们刚才说的，这个问题没有解析解，因此我们需要用数值近似。

![picture](https://www.scratchapixel.com/images/upload/monte-carlo-methods/areacam2.png?)

这里的原理很简单。它由近似于这个积分的结果，通过在像素区域的几个位置采样像素的表面。换句话说，就像蒙特卡罗近似一样，我们将使用“随机抽样”来评估这个积分（并得到一个近似值）。我们需要的是，在像素区域中选择一些随机的采样点，并将它们的颜色平均。现在的问题是我们如何找到这些样本的颜色？当然使用射线追踪！光线会像往常一样从眼睛的位置开始，但是会通过每个随机放置的样本分布在像素区域（图2）。样品的颜色将会是光线在相交点与场景中的物体的颜色。在数学上,我们可以写:

$$L_{pixel} \approx {2 \over N } \sum_{n=1}^N L(x_n),$$

$L(x_n)$表示样本颜色。像往常一样，这只是一个近似值（因此是$\approx$符号）。这种方法被称为蒙特卡罗积分法（尽管与蒙特卡罗近似法相似，但在这种情况下，它被用来求积分的近似值）。对蒙特卡罗集成方法的正式定义感兴趣的读者可以参考下一节课。这只是对这个概念的一个非正式和快速的介绍。

![Figure 3: using Monte Carlo to approximate the color of a surface (using 8 samples in this example).](https://www.scratchapixel.com/images/upload/monte-carlo-methods/mcintegration01.png?)

如果你还不明白这个问题,让我们想象一下我们所看到的通过一个像素是16 x16网格的颜色(如图3所示)。这个问题可能似乎更简单,因为我们只有256独特的颜色所以事实上,找出像素的颜色是可行的在这种情况下,我们只需要总结所有这些颜色和结果除以256。但是如果网格是无穷大的，这个解就不成立。如果我们想要找到这个问题的近似值，我们需要做的就是样本在8个不同位置的图像(8只是一个例子)。它表示样本大小N，它的值可以是你喜欢的任何东西)，在这些位置读取网格的颜色，把这8种颜色加起来，然后除以8。您可以在图3中看到这个想法。

从图3中可以看到，得到的近似接近于平均颜色，但差异是可见的。这是蒙特卡罗方法的陷阱，他们只是给出了近似。该方法的另一个缺陷是每次计算新的近似时，都会得到不同的结果。这是由于该方法的随机性(每次计算一个近似时，8个样本的位置会发生变化)。例如，下图显示了使用8个样本的相同颜色网格的一系列16个近似的结果。

![](https://www.scratchapixel.com/images/upload/monte-carlo-methods/mcintegration02.png?)

好消息是，通过增加样本数量可以减少这个错误。坏消息是，为了最小化误差2，需要两倍的样本。这就是为什么蒙特卡罗方法的名声要慢的原因。更准确的说法是，他们的收敛速度(当样本数量增加时，收敛到正确结果的速度)是相当低的。这将在本课和接下来的课程中详细研究。接下来的一系列图像，分别显示了分别为8、16、32、64、128和256的16种近似。

![](https://www.scratchapixel.com/images/upload/monte-carlo-methods/mcintegration03.png?)

随着样本数目的增加，每一个连续近似的差值也会减小。渲染的差异就是你在渲染中所知道的噪音(假设你使用的是射线追踪器)。它是由实际的解和你的近似之间的差引起的。技术上正确的名字是方差(概率和统计与方差研究有很大关系)。你通常会得到更多的噪音来减少样品的数量，或者通过增加样品数量来表达不同的声音，你可以减少噪音(或方差)。但是注意，从一个近似到另一个近似(假设使用相同数量的样本)所得到的变化量也取决于网格中颜色之间的变化量。在下面的例子中，我们可以看到，网格的颜色和亮度的变化比之前的例子要多得多。虽然在前一种情况下，连续的近似法之间的差异在256个样本中是可见的，但在这个网格和相同数量的样本中，差异更清晰可见。

![](https://www.scratchapixel.com/images/upload/monte-carlo-methods/mcintegration04.png?)
什么时候发生的?当你看到一个像素的许多物体，或者只看到一个或几个具有复杂表面细节的物体。一般情况下，你想避免的情况是，你通过一个像素所看到的视觉复杂度是非常大的，因为越详细的样本，你需要减少噪音。这个概念也涉及到混叠的概念和重要性抽样的概念。下面是我们用来生成这些结果的代码:

```c++
#include <fstream> 
#include <cstdlib> 
#include <cstdio> 
 
int main(int argc, char **argv) 
{ 
        std::ifstream ifs; 
        ifs.open("./tex.pbm"); 
        std::string header; 
        uint32_t w, h, l; 
        ifs >> header; 
        ifs >> w >> h >> l; 
        ifs.ignore(); 
        unsigned char *pixels = new unsigned char[w * h * 3]; 
        ifs.read((char*)pixels, w * h * 3); 
        // sample
        int nsamples = 8; 
        srand48(13); 
        float avgr = 0, avgg = 0, avgb = 0; 
        float sumr = 0, sumg = 0, sumb = 0; 
        for (int n = 0; n < nsamples; ++ n) { 
                float x = drand48() * w; 
                float y = drand48() * h; 
                int i = ((int)(y) * w + (int)(x)) * 3; 
                sumr += pixels[i]; 
                sumg += pixels[i + 1]; 
                sumb += pixels[i + 2]; 
        } 
        sumr /= nsamples; 
        sumg /= nsamples; 
        sumb /= nsamples; 
        for (int y = 0; y < h; ++y) { 
                for (int x = 0; x < w; ++x) { 
                        int i = (y * w + x) * 3; 
                        avgr += pixels[i]; 
                        avgg += pixels[i + 1]; 
                        avgb += pixels[i + 2]; 
                } 
        } 
        avgr /= w * h; 
        avgg /= w * h; 
        avgb /= w * h; 
        printf("Average %0.2f %0.2f %0.2f, Approximation %0.2f %0.2f %0.2f\n", avgr, avgg, avgb, sumr, sumg, sumb); 
        delete [] pixels; 
        return 0; 
} 
```
由于我们使用射线追踪来评估蒙特卡罗积分的样本，该方法被称为蒙特卡罗射线追踪(它也称为随机射线追踪)。

```
三篇开创性的论文介绍了这个方法:绘制方程(Kajiya 1986)，计算机图形的随机抽样(Cook 1986)和分布式射线追踪(Robert L. Cook, Thomas Porter, Loren Carpenter 1984)。
```
现在让我们来谈谈那些有偏见和无偏的术语。在统计学中，我们计算E(X)近似的规则称为估计量。方程:

$$
Approximation(E(X)) = { 1 \over N } \sum_{n=1}^N x_n,
$$

这是一个估计量的例子(实际上，它是蒙特卡罗估计量的简化版本，我们称之为基本估计量。你可以在下节课中找到完整的方程和蒙特卡罗估计量的完整定义。当样本容量N增加时，估计值会更接近期望结果。实际上，我们可以证明，当N趋于无穷时，这个近似收敛于实际结果(检查章节抽样分布)。另一种表达方式是说近似和期望值之间的差值收敛到0当N趋于无穷时，我们可以这样写:

$$
Approximation(E(X)) - E(X) = 0 \text { as N approaches } \infty.
$$


这实际上是蒙特卡罗估计量的情况下。总而言之,蒙特卡罗估计量是无偏估计量。但当估计的结果之间的差异和期望是不同的比0(N趋于无穷时),那么这个估计是有偏见的。这并不意味着尽管估计不收敛到一定值N趋于无穷时(当他们做的是一致的),只比预期,这个值是不同的。乍一看，无偏估计量比偏置估计量好。的确，我们为什么需要或将使用与期望不同的估计量?因为其中一些估计具有有趣的性质。如果偏差足够小，并且估计量比无偏估计量的收敛速度快，这可以看作是一个有趣的特性。这些偏置估计量的结果也可能比无偏估计量的结果有更小的方差。换句话说，如果你用偏置的估计量来计算某个时间的近似值，你可能会发现，与一个无偏估计量(使用相同数量的样本)相比，从一个近似到下一个近似的变化更少。这也可能是一种有趣的品质。总而言之，你可以有一个有偏见的或不带偏见的蒙特卡洛射线追踪器。与无偏差的MC射线追踪器相比，带有偏置的MC射线追踪器的噪声可能会小一些(或更快)，然而，通过使用偏置的估计器，你会引入一些较小的误差(偏差)，与“真实”的结果相比较。一般来说，这种偏差很小(否则估计不会有任何好处)，如果你不知道它在那里，就不值得注意。

![Figure4](https://www.scratchapixel.com/images/upload/monte-carlo-methods/mcintegration05.png?)

我们可以进一步扩展蒙特卡罗射线追踪的概念。所教训介绍阴影(链接),计算颜色的交点P主要或照相机光线与物体的表面,需要集成的光线到达P在西半球的方向取向正常。如果你还没猜出来，这是另一个积分，很粗略地我们可以写成:

$$
L_P = \int_\Omega L_\Omega.
$$

记住教训的阴影,$\Omega$表示西半球。像往常一样，这涉及到在一个连续的区域内积分一些量，没有解析解。因此，我们可以再次使用蒙特卡罗积分方法。这个想法是“sample”半球表面通过创建场景中随机抽样和射击射线从P通过这些样本,得到一个近似的有多少光到达P(图4)。换句话说,我们将随机射线的可见点P,平均的结果。

$$
L_P \approx { 1 \over N } \sum_{n=1}^N L_n.
$$

![Figure5](https://www.scratchapixel.com/images/upload/monte-carlo-methods/mcintegration06.png?)

这就是蒙特卡洛射线追踪器的工作原理。请注意，当我们将光线从P点投射到场景中，以确定光从这个方向产生的光线时，如果我们沿着这条射线与另一个物体相交，我们使用同样的方法来近似这个物体所返回的光的量。这个过程是递归的。因为我们遵循射线的路径，这个算法有时也被称为路径跟踪。您可以在图5中看到它。

这个想法也可以用下面的伪代码来表示。

```c++
Vec3f monteCarloIntegration(P, N) 
{ 
    Vec3f lightAtP = 0; 
    int nsamples = 8; 
    for (int n = 0; n < nsamples; ++n) { 
        Ray sampleRay = sampleRayAboveHemisphere(P, N); 
        Vec3f Phit; 
        Vec3f Nhit; 
        if (traceRay(sampleRay, Phit, Nhit)) { 
            lightAtP += monteCarloIntegration(Phit, Nhit); 
        } 
    } 
    lightAtP /= nsamples; 
 
     return lightAtP; 
} 
 
void render() 
{ 
    Ray r; 
    computeCameraRayDir(r, ...); 
    Vec3f Phit; 
    Vec3f Nhit; 
    if (traceRay(r, Phit, Nhit)) { 
        Vec3f lightAtP = monteCarloIntegration(Phit, Nhit); 
        ... 
    } 
} 
```

我们将在关于路径跟踪的课程中详细研究这个算法。

显然，所有这些都是对蒙特卡罗射线追踪的一种非常快速和近似的介绍。为了得到更准确和完整的信息，我们强烈建议您阅读本课剩余部分，以及以下内容。

>最后，我们假设蒙特卡罗方法是依赖于随机抽样的数值方法来近似结果，特别是积分的结果。这些积分有时可以解决使用其他技术(如果你有兴趣,你可以搜索例如拉斯维加斯算法),然而在接下来的教训,我们将展示他们与其他解决方案相比具有属性,使他们更有用的(特别是解决积分我们必须处理在计算机图形学中)。
>
>蒙特卡洛绝对是渲染领域的核心。它与许多非常重要的其他主题相关联，例如采样、重要性采样、光传输算法，并且还被用于许多其他重要的渲染技术(特别是在阴影中)。

## 接下来是什么?
为了结束这一章，你可以观看这个有趣的视频，它是BBC纪录片的摘录。它显示了通过取平均随机数来发现问题近似的能力。本课的其余部分将涵盖统计学和概率论的基本内容。它涵盖了一些重要的概念，如PDF和CDF的概念，我们将在下次课中广泛使用的逆方法。