---
layout: post
title: 蒙特卡罗方法简介
---

# 蒙特卡罗方法的数学基础01

## 蒙特卡罗方法简介

[原文](https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/monte-carlo-methods-mathematical-foundations)

起初我们不希望将课程设计这么长，包含如此多关于概率论和统计学的内容，但事实是，如果你想了解蒙特卡罗方法，你将要大量涉及到概率论与数理统计理论。

>在这一章，我们将试图了解些蒙特卡罗方法是什么，它们是如何工作的，应用于哪些领域，以及为什么应用于这些领域。这篇简短介绍，是为那些没有时间或者意愿深入学习的读者准备的。但是如果你想认真的学习这些方法，你可能需要阅读所有剩下的章节。
>
>这一课更多地介绍那些构建蒙特卡罗方法的数学工具。蒙特卡罗方法本身将在下一课（蒙特卡罗方法实践）中进一步解释。

### 关于蒙特卡罗的前言

就像许多在CG文献中经常出现的其他术语一样，蒙特卡罗对于初学者看来是一个神奇的词汇。一些在计算机图形学中使用的数学工具某种程度上比较复杂，例如球谐函数，相反蒙特卡罗的原理就其本身而言相对简单（并不意味着容易）。这很棒，因为这种方法能极其方便地解决各种复杂的问题。蒙特卡罗积分法或蒙特卡罗近似法大概是一个很古老的方法，可直到1940年代中期才有了这个朗朗上口的名字。蒙特卡罗是摩纳哥公国的一个地区，以其赌场闻名于世。如同我们将在本课程中所要讲解到的，蒙特卡罗方法与统计学领域有很紧密的联系，它本身对提升你在一场机会游戏中输赢的机会很有帮助，比如轮盘，或任何其他涉及到掷骰子，抽牌等机会游戏，都被看作是一个随机过程。蒙特卡罗方法是由一批著名数学家帮助开发并形式化(费米，乌兰，冯·诺依曼，梅特罗波利斯等)，它对于原子弹开发的研究开展是至关重要的，并在计算机紧密相关的现代科学中非常流行（冯诺伊曼本人发明了第一代计算机）。蒙特卡罗积分需要大量计算，如果没有计算机的参与，它将非常乏味冗长，而大规模计算恰好是计算机所擅长的。现在我们回顾了关于蒙特卡罗的历史和最初的命名的起源，让我们尝试解释下什么是蒙特卡罗。可惜，我们前面的介绍很简短，蒙特卡罗方法的数学意义涉及到许多统计学和概率论的重要概念。在着眼介绍蒙特卡罗方法前，我们首先要和大家回顾这些概念。

![picture](https://www.scratchapixel.com/images/upload/monte-carlo-methods/roulette.png?)

### 蒙特卡罗方法简介

![pictrue](https://www.scratchapixel.com/images/upload/monte-carlo-methods/jellybeans01.png?) 

蒙特卡罗是什么？蒙特卡罗方法背后的概念既简单又健壮。然而，很快我们会发现，它需要的计算量很大，这就是为什么它的普及时间与计算机技术的出现相一致的原因。生活中的许多事情都很难准确评估，尤其是涉及到非常大的数字时。例如，虽然并非不可能，但要计算1罐1公斤装的果冻豆的的数量可能要花很长时间。你可以手动一个一个地数，但这可能要花很长时间（这可不是个讨人喜欢的工作）。计算一个国家所有成年人口的平均身高，需要测量每个人的身高，并将其相加，再除以总人数。这是一项可能需要很长时间的任务。我们可以做的是取这个总体的样本然后计算它的平均高度。它不可能准确地给出整个总体的平均高度，但是这个方法给出了一个结果可以作为真实结果很一个很好的**近似值**。我们为了速度而放弃了准确性。抽样调查也被称为**统计学**就是基于这一我们所熟知的原则的。有趣的是，近似值和整个总体的准确平均值可能有些时候是完全相同的。这只是出于偶然。在大多数情况下，数字将会有所差异。我们可能想问的一个问题是，差异有多大？事实上，随着样本数量的增大，这个近似值收敛于精确的数值。换句话说，近似值和实际结果之间的误差随着样本容量的减小而减小。我们为了速度而放弃了准确性。民调也被称为统计数据是基于这一原则的，我们都很熟悉这一原则。有趣的是，整个种群的近似和准确的平均值可能有些时候是完全相同的。这只是由于偶然。在大多数情况下，数字将会有所不同。我们可能想问的一个问题是，有什么不同吗?事实上，随着样本容量的增大，这个近似值收敛于精确值。换句话说，近似值和实际结果之间的误差随着样本数量的增加而减小。直觉上，这个想法很容易理解，但是在下一章中，我们会将它(从数学的角度)公式化，用另一种不同的方式阐述这个概念。请注意，为了公平起见，样本元素需要等概率地随机选取。

注意，一个人的身高是一个随机数。实际上可以是任何有随机性质的东西。因此，当你对一个统计总体进行抽样时，通过随机地从这个总体中选取元素，并测量它们的高度来估算平均高度，每一个测量结果都是一个随机值（因为样本中的每个人可能有不同的高度）。有趣的是，随机值的总和，是另一个随机值。如果你不能预测每一个用来求和的值是多少，你怎么能预测它们求和的结果呢？因此，求和的结果是一个随机值。

对于一个数学家来说，人口的高度会被称为**随机变量**，因为组成这个总体的人的身高是随机的。我们通常用大写字母表示随机变量。比如大写字母$X$。

在统计学中，如前面所提及到的，构成总体的要素是随机的，用一个小写字母表示，通常是$x$。例如，如果我们写$x_2$，这表示的是第二个人的身高（这是随机的）。所有这些$x$也可以被看作是随机变量$X$的可能结果，如果我们称$X$为随机变量（人口高度），我们可以用下面的伪数学公式来表示成人平均身高近似值:

$$
Approximation(Average(X)) = { 1 \over N} \sum_{n=1}^N x_n.
$$

可以理解为，随机变量$X$平均值的近似值（一个特定国家的成年人口的高度），等于从这个总体随机选择$N$个成人的高度（样本）的总和（$\Sigma$符号），除以$N$（样本数量）。这就是我们所说的**蒙特卡罗近似法**。它是指，对于一组庞大数量个体的一些属性，通过从该总体随机选择$N$个个体的性质求平均值作为该总体属性的近似值。你也可以说，蒙特卡罗近似法，实际上是一种用样本求近似值的方法。下一章我们将学到，这个需要被近似的值被称为数学期望。如前所述一个给定的国家的成年人口的高度可以被看作是一个随机变量$X$。但是需要注意，其平均值（例如，通过对所有人的身高求平均值得到，并且每个人的高度值也是一个随机值）是唯一的（为了避免与通常用字母$N$表示的样本数量混淆，我们将使用$M$表示整个总体的大小）:

$$
Average(X) = { 1 \over M\ } (x_1 + x_2 + ... x_M),
$$

这里$x_1, x_2, ... x_M$对应组成前面的总体中的每个人的身高（如果我们要举个例子）。在统计学中，随机变量X的平均值被称为**期望**，并被写成$E(X)$。

>总而言之，蒙特卡罗近似法（这是MC方法之一）是一种利用样本来近似随机变量期望的技术。可以用下面的公式来定义它：
>
>$$E(X) \approx { 1 \over N } \sum_{n = 1}^N x_n.$$
>这个数学符号$\approx$表示，这个符号的右边的公式所给出得随机变量$X$的期望值$E(X)$，实际上只是随机变量$X$的期望值$E(X)$的"近似"。注意，在某种程度上，它只是随机值($x_n$)的平均值。

这就是所有我们想要揭开的关于蒙特卡罗这个神秘术语背后的秘密。但是，在这个简单介绍的最后，让我们来解释一下这个方法之所以是有用的原因。前面提到过，$E(X)$有时是难以求解的。这意味着你不能以一种有效的方式计算$E(X)$。尤其对庞大规模的“总体”求$E(X)$的时候的确如此，例如计算一个国家成年人口的平均身高。在这种情况下，MC近似法提供了一个至少非常简单和快速的方法来近似估算这个期望值。它不会给出确切的值，但它可以得到足够近似的结果，同时计算花费可能仅是计算精确值的几分之一。

### 蒙特卡罗，偏置和无偏射线追踪

为了结束这个简短的介绍，我们意识到读者中很多人都听说过**蒙特卡罗射线追踪**这个术语，还有**偏置**和**无偏**的射线追踪这个词，很可能是看到这个页面，希望能从中找到这些术语的解释。让我们做一个简单的解释，尽管我们非常建议你们阅读这一课的其余部分以及下面的内容，以便深入地回答这些问题。

![picture](https://www.scratchapixel.com/images/upload/monte-carlo-methods/areacam1.png?)

想象一下你想用数码相机拍张照片。如果你把图像的表面分割成一个个规则的网格（或者我们称之为像素），注意每一个像素实际上都可以被看作是很小但是仍然是连续的表面，在这个场景中，由物体所反射的光会落到上面。这些光最终会转化为单一颜色（我们稍后将讨论这个过程）但是如果你从这些像素看过去，您可能注意到，实际上看到不止一个对象，或者某个物体的表面上的不止一种颜色，分别映射于像素的不同区域。我们已经通过图1展示了这个想法。理想情况下，我们要做的是计算从这个表面上所反射的光的量。这通常是一个棘手问题，从某种意义上说，没有办法可以在一个像素的表面上对通过这像素的光的数量求积分。虽然我们可以用数学方程来写出这个想法，但是这个方程实际上并没有解。

$$
L_{pixel} = \int_{pixel area} L(x_p) dA,
$$

$L$在这里，代表辐射率（在放射测量学的课程中会解释到）。你可以将这个方程理解为"实际到达一个像素数的光的量（方程左边的$L$项也就是最终将保存的该像素的颜色）可以通过对输入的辐射率（击中该像素上的光的数量）在整个像素区域上求积分来得到"。就像我们刚才说的，这个问题没有解析解，因此我们需要用数值近似。

![picture](https://www.scratchapixel.com/images/upload/monte-carlo-methods/areacam2.png?)

这里的原理很简单。通过在像素表面采样数个像素区域内的位置来估算这个积分的结果。换句话说，就像蒙特卡罗近似法一样，我们将使用“随机抽样”来估算这个积分（并得到一个近似值）。我们需要的是，在像素区域中选择一些随机的采样点，并求它们颜色的平均值。现在的问题是我们如何找到这些样本的颜色？当然使用射线追踪！光线会像往常一样从眼睛的位置出发，但是会通过每个随机分布在像素区域的样本（图2）。样本的颜色将会是场景中与光线相交的物体在相交点的颜色。在数学上，我们可以写成:

$$L_{pixel} \approx {1 \over N } \sum_{n=1}^N L(x_n),$$

$L(x_n)$表示样本颜色。通常，这只是一个近似值（因此是$\approx$符号）。这种方法被称为蒙特卡罗积分法（尽管与蒙特卡罗近似法相似，但在这种情况下，它被用来求积分的近似值）。对蒙特卡罗积分法的正式定义感兴趣的读者可以参考下一节课。这只是对这个概念的一个非正式和简短的介绍。

![Figure 3: using Monte Carlo to approximate the color of a surface (using 8 samples in this example).](https://www.scratchapixel.com/images/upload/monte-carlo-methods/mcintegration01.png?)

如果你对这个问题还不很清楚，让我们想象一下我们所看到的通过一个像素是16x16网格的颜色（如图3所示）。这个例子中可能似乎更简单，因为实际上我们只有256种独特的颜色，所以在这种情况下得出像素的颜色是可行的，我们只需要对所有这些颜色求和，并将结果除以256。但是如果网格是无穷大的，这个解决办法就不成了。如果我们想要找到这个问题的近似值，我们需要做的就对这个图像在8个不同位置采样（8只是一个例子。它表示样本大小$N$，它的值可以是任意的），在这些位置读取网格的颜色，把这8种颜色加起来，然后除以8。图3中展示了这个想法。

从图3中可以看到，得到的结果近似接近于平均颜色，但还是可以看出之间的差异。这是蒙特卡罗方法的缺陷，它们只是给出了近似结果。该方法的另一个缺陷是每次计算新的近似值时，都会得到不同的结果。这是由于该方法的随机性（当每计算一个近似值时，8个样本的位置会随机发生变化）决定的。例如，下图显示了使用8个样本的相同颜色网格的一系列16个近似的结果。

![](https://www.scratchapixel.com/images/upload/monte-carlo-methods/mcintegration02.png?)

好消息是，通过增加样本数量可以减少这个误差。坏消息是，为了减少一半的误差，需要两倍的样本。这就是为什么蒙特卡罗方法被冠以计算缓慢的名声的原因。更准确的说法是，它们的收敛速度（当样本数量增加时，收敛到正确结果的速度）是相当低的。这将在本课和接下来的课程中详细研究。接下来的一系列图像，展示了采样次数分别为8、16、32、64、128和256的各16个近似结果。

![](https://www.scratchapixel.com/images/upload/monte-carlo-methods/mcintegration03.png?)

随着样本数目的增加，每一个连续近似的差值也会减小。渲染的差异就是你在渲染中所知道的**噪音**（假设你使用的是射线追踪器）。它是由实际的解和你的近似值之间的差异引起的。技术上正确的名字是**方差**（概率和统计与方差研究有很大关系）。由于样本数量过少，你通常会得到更多的噪音，或者换句话说，通过增加样本的数量，你可以减少噪音（或者说方差）。但是注意，从一个近似到另一个近似（假设使用相同数量的样本）所得到的变化量也取决于网格中颜色之间的差异。在下面的例子中，我们可以看到，网格的颜色和亮度的变化比之前的例子要多得多。虽然在前一种情况下，连续的近似值之间的差异在256次采样中是几乎无法察觉，但在这个网格和相同数量的采样中，差异更清晰可见。

![](https://www.scratchapixel.com/images/upload/monte-carlo-methods/mcintegration04.png?)
什么时候会发生这种情况？当你通过一个像素看到许多物体，或者只看到一个或几个具有复杂表面细节的物体。一般情况下，你想避免这种情况，即通过一个像素所看到的视觉复杂度非常大，因为细节越多，就需要越多的的样本来减少噪音。这个概念也涉及到**混叠**的概念和**重要性采样**的概念。下面是我们用来生成这些结果的代码:

```c++
#include <fstream> 
#include <cstdlib> 
#include <cstdio> 
 
int main(int argc, char **argv) 
{ 
        std::ifstream ifs; 
        ifs.open("./tex.pbm"); 
        std::string header; 
        uint32_t w, h, l; 
        ifs >> header; 
        ifs >> w >> h >> l; 
        ifs.ignore(); 
        unsigned char *pixels = new unsigned char[w * h * 3]; 
        ifs.read((char*)pixels, w * h * 3); 
        // sample
        int nsamples = 8; 
        srand48(13); 
        float avgr = 0, avgg = 0, avgb = 0; 
        float sumr = 0, sumg = 0, sumb = 0; 
        for (int n = 0; n < nsamples; ++ n) { 
                float x = drand48() * w; 
                float y = drand48() * h; 
                int i = ((int)(y) * w + (int)(x)) * 3; 
                sumr += pixels[i]; 
                sumg += pixels[i + 1]; 
                sumb += pixels[i + 2]; 
        } 
        sumr /= nsamples; 
        sumg /= nsamples; 
        sumb /= nsamples; 
        for (int y = 0; y < h; ++y) { 
                for (int x = 0; x < w; ++x) { 
                        int i = (y * w + x) * 3; 
                        avgr += pixels[i]; 
                        avgg += pixels[i + 1]; 
                        avgb += pixels[i + 2]; 
                } 
        } 
        avgr /= w * h; 
        avgg /= w * h; 
        avgb /= w * h; 
        printf("Average %0.2f %0.2f %0.2f, Approximation %0.2f %0.2f %0.2f\n", avgr, avgg, avgb, sumr, sumg, sumb); 
        delete [] pixels; 
        return 0; 
} 
```
由于我们使用射线追踪来对蒙特卡罗积分的样本求值，该方法被称为蒙特卡罗射线追踪(它也称为随机射线追踪)。

>三篇开创性的论文介绍了这个方法:*The Rendering Equation*(Kajiya 1986)，*Stochastic Sampling in Computer Graphics*(Cook 1986)和*Distributed Ray-Tracing*(Robert L. Cook, Thomas Porter, Loren Carpenter 1984)。

现在让我们来谈谈关于**有偏**和**无偏**这两个术语。在统计学中，我们计算$E(X)$近似值的法则称为**估计量**。方程:

$$
Approximation(E(X)) = { 1 \over N } \sum_{n=1}^N x_n,
$$

这是一个估计量的例子(实际上，它是**蒙特卡罗估计量**的简化版本，我们称之为**基本估计量**。你可以在下节课中找到完整的方程和蒙特卡罗估计量的完整定义。)当样本容量$N$增加，估计值会更接近期望结果，这种估计量被称作是**无偏的**。实际上，我们可以证明，当$N$趋于无穷时，这个近似收敛于实际结果(详见抽样分布章节)。另一种表达方式是说，当$N$趋于无穷时，近似值和期望值之间的差值收敛于0，我们可以这样写:

$$
Approximation(E(X)) - E(X) = 0 \text { as N approaches } \infty.
$$

这实际上这里是对蒙特卡罗估计量的情况而说的。简而言之，蒙特卡罗估计量是无偏估计量。但是，当估计量的结果和数学期望值之间的差异不等于0($N$趋于无穷时)，那么这个估计量就是**偏置**估计量。但这并不意味着当$N$趋于无穷时，估计量不会收敛到某一确定值(这时我们称它们为一致的)，仅仅是和期望值不同而已。乍一看，无偏估计量比偏置估计量好。我们究竟为什么需要用到与期望不同的估计量？因为某些些偏置估计量具有一些很有趣的性质。如果偏执足够小，并且这个估计量比无偏估计量的收敛速度快，这就可以看作是一个有趣的特性。这些偏置估计量的结果也可能比无偏估计量的结果在相同样本数量的情况下有更小的方差。换句话说，如果你用偏置的估计量来计算数次近似值，你可能会发现，与一个无偏估计量(使用相同数量的样本)相比，从每个近似值之间的变化更小。这也可能是一种有趣的特性。总而言之，你可以有一个有偏置的或无偏置的蒙特卡罗射线追踪器。与无偏置的MC射线追踪器相比，带有偏置的MC射线追踪器的噪声可能会小一些(或这说收敛更快)，然而，通过使用偏置的估计量，得到的结果与“真实”的结果之间的误差(偏差)会更小。一般来说，这种偏差很小(否则这个估计量也没什么用)，很难被注意到，就如同你不知道它在那里一样。

![Figure4](https://www.scratchapixel.com/images/upload/monte-carlo-methods/mcintegration05.png?)

我们可以进一步扩展蒙特卡罗射线追踪的概念。着色简介的课程中会提及到，计算主射线或者叫照相机射线与物体的表面的交点$P$的颜色，需要对到达$P$点的光线，在$P$点法线方向的半球上求积分。如果你还没猜出来，这是另一个积分，我们将它粗略地可以写成:

$$
L_P = \int_\Omega L_\Omega.
$$

回忆在着色相关的课程中，$\Omega$表示半球。这涉及到一些量在一个连续的区域内求积分，但是通常该积分没有解析解。因此，我们可以再次使用蒙特卡罗积分法。这个想法是，在半球表面随机“采样”，由$P$为起点并通过样本点向场景中发射射线，得到一个到达$P$的光强度的近似值(图4)。换句话说，我们将从可见点$P$像场景中随机投射射线，并计算这些结果的平均值。

$$
L_P \approx { 1 \over N } \sum_{n=1}^N L_n.
$$

![Figure5](https://www.scratchapixel.com/images/upload/monte-carlo-methods/mcintegration06.png?)

这就是蒙特卡罗射线追踪器的工作原理。请注意，当我们将射线从$P$点投射到场景中，以确定有多少光从这个方向来，如果这条射线与场景中另一个物体相交，我们使用同样的方法来近似估算从这个物体所返回的光的量。这个过程是递归的。因为我们遵循射线的路径，这个算法有时也被称为路径跟踪。您可以在图5中看到它。

这个想法也可以用下面的伪代码来表示。

```c++
Vec3f monteCarloIntegration(P, N) 
{ 
    Vec3f lightAtP = 0; 
    int nsamples = 8; 
    for (int n = 0; n < nsamples; ++n) { 
        Ray sampleRay = sampleRayAboveHemisphere(P, N); 
        Vec3f Phit; 
        Vec3f Nhit; 
        if (traceRay(sampleRay, Phit, Nhit)) { 
            lightAtP += monteCarloIntegration(Phit, Nhit); 
        } 
    } 
    lightAtP /= nsamples; 
 
     return lightAtP; 
} 
 
void render() 
{ 
    Ray r; 
    computeCameraRayDir(r, ...); 
    Vec3f Phit; 
    Vec3f Nhit; 
    if (traceRay(r, Phit, Nhit)) { 
        Vec3f lightAtP = monteCarloIntegration(Phit, Nhit); 
        ... 
    } 
} 
```

我们将在关于路径跟踪的课程中详细研究这个算法。

显然，所有这些都是对蒙特卡罗射线追踪简短粗略的介绍。为了得到更准确和完整的信息，我们强烈建议您阅读本课剩余部分，以及以下内容。

>最后，我们说蒙特卡罗方法是基于随机抽样来估算近似结果的数值方法，特别是积分的结果。这些积分有时可以使用其他方法求解（如果你有兴趣，你可以搜索例如拉斯维加斯算法），然而在接下来的课程，我们将展示，蒙特卡罗方法具有某些特性，使得它与其他解决方案相比更有优越性（特别是在计算机图形学中我们必须处理的积分求解问题）。
>
>蒙特卡罗绝对是渲染领域的核心。它与许多其他非常重要的主题密切相关，例如采样、重要性采样、光传输算法，并且还被用于许多其他重要的渲染技术（特别是着色技术）。

### 接下来是什么?
为了结束这一章，你可以观看这个有趣的视频，它是BBC纪录片的摘录。它显示了通过取平均随机数来发现问题近似的能力。本课的其余部分将涵盖统计学和概率论的基本内容。它涵盖了一些重要的概念，如PDF和CDF的概念，我们将在下次课中广泛使用的逆方法。